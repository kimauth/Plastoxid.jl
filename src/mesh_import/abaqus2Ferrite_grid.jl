using Plastoxid


function abaqus2Ferrite_grid(path::String, l::Float64 = 1.0)
    abaqus_mesh=load_abaqus_mesh(path)
    nodes=create_nodes(abaqus_mesh, l)
    cells=create_cells(abaqus_mesh)
    nodesets=create_nodesets(abaqus_mesh)
    # facesets=create_facesets(abaqus_mesh, cells) #relies on elementset "boundary_elements"
    facesets=Dict{String,Set{FaceIndex}}()
    cellsets = create_cellsets(abaqus_mesh)
    boundary_matrix = spzeros(Bool, 0, 0)
    # grid=Grid(cells, nodes; cellsets, nodesets, facesets, boundary_matrix)
    grid = Grid(cells, nodes; cellsets, nodesets)
    return grid
end

#2D mesh
function create_nodes(abaqus_mesh::AbaqusMesh, l::Float64=1.0)
    n_nodes=length(abaqus_mesh.nodes.numbers)
    nodes=Array{Node{2, Float64}}(undef, n_nodes)
    for node_number in abaqus_mesh.nodes.numbers
        x=Tensor{1,2}(abaqus_mesh.nodes.coordinates[1:2, node_number] .* l)
        nodes[node_number] = Node(x)
    end
    return nodes
end


const COH2D4_NUMBERING = [1,2,4,3]

function create_cells(abaqus_mesh::AbaqusMesh)
    n_elements = 0
    for key in keys(abaqus_mesh.elements)
        n_elements += length(abaqus_mesh.elements[key].numbers)
    end
    cells = Array{Ferrite.AbstractCell}(undef, n_elements)
    for key in keys(abaqus_mesh.elements)
        elements=abaqus_mesh.elements[key] #retrieve abaqus elements
        #Cells can only be created by tuples, not by arrays
        if key ∈ ["CPE4", "CPS4", "CPE4R", "CPS4R"]
            for (i, element_number) in enumerate(elements.numbers)
                node_numbers=elements.topology[:, i]
                cells[element_number] = Quadrilateral(ntuple(j->node_numbers[j], length(node_numbers)))
            end
        elseif key ∈ ["CPE3", "CPS3"]
            for (i, element_number) in enumerate(elements.numbers)
                node_numbers=elements.topology[:, i]
                cells[element_number] = Triangle(ntuple(j->node_numbers[j], length(node_numbers)))
            end
        elseif key ∈ ["COH2D4"]
            for (i, element_number) in enumerate(elements.numbers)
                node_numbers=elements.topology[:, i]
                # 2D element from Abaqus
                cells[element_number] = CohesiveQuadrilateral(ntuple(j->node_numbers[COH2D4_NUMBERING][j], length(node_numbers)))
            end
        end
    end
    return cells
end

function create_nodesets(abaqus_mesh::AbaqusMesh)
    nodesets=Dict{String,Set{Int}}()
    for key in keys(abaqus_mesh.node_sets)
        nodeset=Dict(key=>Set(abaqus_mesh.node_sets[key]))
        merge!(nodesets, nodeset)
    end
    return nodesets
end

# assumes a cellset boundary_elements. Don't do that. Import facesets generated by neper?
function create_facesets(abaqus_mesh::AbaqusMesh, cells)
    facesets=Dict{String,Set{FaceIndex}}()
    for key in keys(abaqus_mesh.node_sets)
        merge!(facesets, Dict(key=>Set{Tuple{Int,Int}}()))
    end
    boundary_elements=abaqus_mesh.element_sets["boundary_elements"]
    for be_number in boundary_elements
        for (face, face_nodes) in enumerate(Ferrite.faces(cells[be_number]))
            for key in keys(abaqus_mesh.node_sets)
                if face_nodes[1] ∈ abaqus_mesh.node_sets[key] && face_nodes[2] ∈ abaqus_mesh.node_sets[key]
                    push!(facesets[key], FaceIndex(be_number, face))
                end
            end
        end
    end
    return facesets
end

function create_cellsets(abaqus_mesh::AbaqusMesh)
    cellsets = Dict{String,Set{Int}}()
    for key in keys(abaqus_mesh.elements)
        merge!(cellsets, Dict(key => Set(abaqus_mesh.elements[key].numbers)))
    end
    for key in keys(abaqus_mesh.element_sets)
        merge!(cellsets, Dict(key => Set(abaqus_mesh.element_sets[key])))
    end
    return cellsets
end
